package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"golang.org/x/sync/errgroup"

	"github.com/PrebenVerEecke/omnidocsscanner/internal/auth"
	"github.com/PrebenVerEecke/omnidocsscanner/internal/checks"
	"github.com/PrebenVerEecke/omnidocsscanner/internal/client"
	"github.com/PrebenVerEecke/omnidocsscanner/internal/report"
	"github.com/PrebenVerEecke/omnidocsscanner/internal/session"

	// Import checks to register them
	_ "github.com/PrebenVerEecke/omnidocsscanner/internal/checks"
)

var (
	version = "0.1.0"
	cfg     Config
)

type Config struct {
	BaseURL      string  `mapstructure:"base-url"`
	Cabinet      string  `mapstructure:"cabinet"`
	Username     string  `mapstructure:"username"`
	Password     string  `mapstructure:"password"`
	Auth         bool    `mapstructure:"auth"`
	Unauth       bool    `mapstructure:"unauth"`
	Include      []string `mapstructure:"include"`
	Exclude      []string `mapstructure:"exclude"`
	Timeout      string  `mapstructure:"timeout"`
	Concurrency  int     `mapstructure:"concurrency"`
	RateLimit    float64 `mapstructure:"rate-limit"`
	Proxy        string  `mapstructure:"proxy"`
	InsecureTLS  bool    `mapstructure:"insecure-tls"`
	OutputJSON   string  `mapstructure:"output-json"`
	OutputSARIF  string  `mapstructure:"output-sarif"`
	OutputJUnit  string  `mapstructure:"output-junit"`
	Dangerous    bool    `mapstructure:"dangerous"`
	MaxIDs       int     `mapstructure:"max-ids"`
	Quiet        bool    `mapstructure:"quiet"`
	Verbose      bool    `mapstructure:"verbose"`
}

func main() {
	rootCmd := &cobra.Command{
		Use:     "newgenone-pentest",
		Short:   "Security testing tool for Omnidocs NewgenONE integrations",
		Long:    `A comprehensive CLI tool for discovering misconfigurations and vulnerabilities in Omnidocs NewgenONE deployments.`,
		Version: version,
		RunE:    runPentest,
	}

	setupFlags(rootCmd)
	setupViper(rootCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func setupFlags(cmd *cobra.Command) {
	// Required flags
	cmd.Flags().String("base-url", "", "Base URL of the NewgenONE instance (required)")
	cmd.MarkFlagRequired("base-url")

	// Configuration flags
	cmd.Flags().String("cabinet", "newgenso", "Default cabinet name")
	cmd.Flags().String("username", "", "Username for authentication")
	cmd.Flags().String("password", "", "Password for authentication")
	cmd.Flags().Bool("auth", true, "Run authenticated checks")
	cmd.Flags().Bool("unauth", true, "Run unauthenticated checks")

	// Path filters
	cmd.Flags().StringSlice("include", []string{}, "Extra paths to include")
	cmd.Flags().StringSlice("exclude", []string{}, "Paths to exclude (glob/regex)")

	// Performance flags
	cmd.Flags().String("timeout", "10s", "Request timeout")
	cmd.Flags().Int("concurrency", 10, "Maximum concurrent requests")
	cmd.Flags().Float64("rate-limit", 5.0, "Rate limit in requests per second")

	// Network flags
	cmd.Flags().String("proxy", "", "Proxy URL (http:// or socks5://)")
	cmd.Flags().Bool("insecure-tls", false, "Skip TLS certificate verification")

	// Output flags
	cmd.Flags().String("output-json", "", "Output findings to JSON file")
	cmd.Flags().String("output-sarif", "", "Output findings to SARIF file")
	cmd.Flags().String("output-junit", "", "Output findings to JUnit XML file")

	// Safety flags
	cmd.Flags().Bool("dangerous", false, "Enable state-changing tests (uploads, etc.)")
	cmd.Flags().Int("max-ids", 100, "Maximum number of IDs to probe for IDOR/BOLA")

	// UX flags
	cmd.Flags().BoolP("quiet", "q", false, "Quiet mode")
	cmd.Flags().BoolP("verbose", "v", false, "Verbose output")
}

func setupViper(cmd *cobra.Command) {
	viper.SetEnvPrefix("NEWGEN")
	viper.AutomaticEnv()
	viper.BindPFlags(cmd.Flags())
}

func runPentest(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle interrupt signals
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		fmt.Println("\nReceived interrupt signal, shutting down...")
		cancel()
	}()

	// Bind configuration
	if err := viper.Unmarshal(&cfg); err != nil {
		return fmt.Errorf("failed to parse configuration: %w", err)
	}

	fmt.Printf("Starting NewgenONE pentest against %s\n", cfg.BaseURL)

	// Create HTTP client
	httpClient, err := client.New(client.Config{
		Timeout:     parseDuration(cfg.Timeout),
		RateLimit:   cfg.RateLimit,
		Proxy:       cfg.Proxy,
		InsecureTLS: cfg.InsecureTLS,
	})
	if err != nil {
		return fmt.Errorf("failed to create HTTP client: %w", err)
	}

	// Create session
	sess, err := session.New(httpClient, cfg.BaseURL)
	if err != nil {
		return fmt.Errorf("failed to create session: %w", err)
	}

	// Handle authentication if requested
	if cfg.Auth {
		if err := handleAuthentication(ctx, sess); err != nil {
			if cfg.Verbose {
				fmt.Printf("Authentication failed: %v\n", err)
			}
			if !cfg.Unauth {
				return fmt.Errorf("authentication required but failed: %w", err)
			}
		}
	}

	// Run security checks
	findings, err := runChecks(ctx, sess)
	if err != nil {
		return fmt.Errorf("failed to run checks: %w", err)
	}

	// Generate and write report
	configMap := map[string]interface{}{
		"cabinet":      cfg.Cabinet,
		"auth":         cfg.Auth,
		"unauth":       cfg.Unauth,
		"timeout":      cfg.Timeout,
		"concurrency":  cfg.Concurrency,
		"rate_limit":   cfg.RateLimit,
		"insecure_tls": cfg.InsecureTLS,
		"dangerous":    cfg.Dangerous,
		"max_ids":      cfg.MaxIDs,
	}

	reportData := report.GenerateReport(cfg.BaseURL, configMap, findings)

	consoleWriter := &report.ConsoleWriter{
		Quiet:   cfg.Quiet,
		Verbose: cfg.Verbose,
	}

	jsonWriter := &report.JSONWriter{
		FilePath: cfg.OutputJSON,
	}

	sarifWriter := &report.SARIFWriter{
		FilePath: cfg.OutputSARIF,
	}

	if err := report.WriteReport(reportData, consoleWriter, jsonWriter, sarifWriter); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	return nil
}

func handleAuthentication(ctx context.Context, sess *session.Session) error {
	var username, password string

	// Get credentials
	if cfg.Username == "" {
		fmt.Print("Username: ")
		fmt.Scanln(&username)
	} else {
		username = cfg.Username
	}

	if cfg.Password == "" {
		fmt.Print("Password: ")
		// Use bufio for secure password input
		passwordBytes, err := readPassword()
		if err != nil {
			return fmt.Errorf("failed to read password: %w", err)
		}
		password = string(passwordBytes)
	} else {
		password = cfg.Password
	}

	// Try different authentication methods
	authenticators := []auth.Authenticator{
		auth.NewFormSessionAuth(),
		auth.NewJWTAuth(),
	}

	for _, authenticator := range authenticators {
		fmt.Printf("Trying %s authentication...\n", authenticator.Name())

		_, err := authenticator.Login(ctx, sess, sess.BaseURL, username, password)
		if err == nil {
			fmt.Printf("✅ Authentication successful using %s\n", authenticator.Name())
			return nil
		}

		if cfg.Verbose {
			fmt.Printf("❌ %s authentication failed: %v\n", authenticator.Name(), err)
		}
	}

	return fmt.Errorf("all authentication methods failed")
}

func runChecks(ctx context.Context, sess *session.Session) ([]checks.Finding, error) {
	var allFindings []checks.Finding

	// Create error group for concurrent execution
	g, gctx := errgroup.WithContext(ctx)
	g.SetLimit(cfg.Concurrency)

	findingsChan := make(chan []checks.Finding, len(checks.Registry))

	// Run each check concurrently
	for _, check := range checks.Registry {
		check := check // capture loop variable
		g.Go(func() error {
			select {
			case <-gctx.Done():
				return gctx.Err()
			default:
				findings, err := check.Run(gctx, sess, sess.BaseURL, cfg)
				if err != nil {
					if cfg.Verbose {
						fmt.Printf("Check %s failed: %v\n", check.ID(), err)
					}
					return nil // Don't fail the whole run for one check failure
				}
				findingsChan <- findings
				return nil
			}
		})
	}

	// Wait for all checks to complete
	if err := g.Wait(); err != nil {
		return nil, err
	}
	close(findingsChan)

	// Collect all findings
	for findings := range findingsChan {
		allFindings = append(allFindings, findings...)
	}

	return allFindings, nil
}

func parseDuration(s string) time.Duration {
	if d, err := time.ParseDuration(s); err == nil {
		return d
	}
	// Default to 10 seconds
	return 10 * time.Second
}

func readPassword() ([]byte, error) {
	// For now, just read from stdin. In production, use a secure method
	var password string
	fmt.Scanln(&password)
	return []byte(strings.TrimSpace(password)), nil
}
